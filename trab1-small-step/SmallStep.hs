module SmallStep where

import Estado
import Tipo

smallStep :: (Exp, Estado) -> (Exp, Estado)
smallStep (Var x, s)               = (Num (procuraVar s x), s)
smallStep (Som (Num x) (Num y), s) = (Num (x+y), s)
smallStep (Som (Num x) e2, s)      = (Som (Num x) ef, s) where (ef, _) = smallStep (e2, s)
smallStep (Som e1 e2, s)           = (Som ef e2, s) where (ef, _) = smallStep (e1, s)
smallStep (Sub (Num x) (Num y), s) = (Num (x-y), s)
smallStep (Sub (Num x) e2, s)      = (Sub (Num x) ef, s) where (ef, _) = smallStep (e2, s)
smallStep (Sub e1 e2, s)           = (Sub ef e2, s) where (ef, _) = smallStep (e1, s)
smallStep (Mul (Num x) (Num y), s) = (Num (x*y), s)
smallStep (Mul (Num x) e2, s)      = (Mul (Num x) ef, s) where (ef, _) = smallStep (e2, s)
smallStep (Mul e1 e2, s)           = (Mul ef e2, s) where (ef, _) = smallStep (e1, s)
smallStep (Not FALSE, s)           = (TRUE, s)
smallStep (Not TRUE,  s)           = (FALSE, s)
smallStep (Not b, s)               = (Not bn, s) where (bn, _) = smallStep (b, s)
smallStep (And TRUE  b2, s)        = (b2, s)
smallStep (And FALSE b2, s)        = (FALSE, s)
smallStep (And b1 b2, s)           = (And bn b2, s) where (bn, _) = smallStep (b1, s)
smallStep (Or FALSE b2, s)         = (b2, s)
smallStep (Or TRUE  b2, s)         = (TRUE, s)
smallStep (Or b1 b2, s)            = (Or  bn b2, s) where (bn, _) = smallStep (b1, s)
smallStep (Ig (Num x) (Num y), s)  = (if x == y then TRUE else FALSE, s)
smallStep (Ig (Num x) b, s)        = (Ig (Num x) bn, s) where (bn, _) = smallStep (b, s)
smallStep (Ig b1      b2, s)       = (Ig bn b2, s) where (bn, _) = smallStep (b1, s)
smallStep (Leq (Num x) (Num y), s) = (if x <= y then TRUE else FALSE, s)
smallStep (Leq (Num x) b, s)       = (Leq (Num x) bn, s) where (bn, _) = smallStep (b, s)
smallStep (Leq b1      b2, s)      = (Leq bn b2, s) where (bn, _) = smallStep (b1, s)
smallStep (Atrib (Var v) (Num x), s) = (Skip, ns) where ns = mudaVar s v x
smallStep (Atrib (Var v) a, s)       = (Atrib (Var v) an, s) where (an, _) = smallStep (a, s)
smallStep (Seq Skip  c,  s)          = (c, s)
smallStep (Seq Throw c,  s)          = (Throw, s)
smallStep (Seq c1    c2, s)          = (Seq cn c2, sn) where (cn, sn) = smallStep (c1, s)
smallStep (If TRUE  c1 c2, s)        = (c1, s)
smallStep (If FALSE c1 c2, s)        = (c2, s)
smallStep (If b     c1 c2, s)        = (If bn c1 c2, s) where (bn, _) = smallStep (b, s)
smallStep (Catch Skip  c,  s)        = (Skip, s)
smallStep (Catch Throw c,  s)        = (c, s)
smallStep (Catch c1    c2, s)        = (Catch cn c2, sn) where (cn, sn) = smallStep (c1, s)
smallStep (While b c, s)             = (If b (Seq c (While b c)) (Skip), s)

interpret :: (Exp, Estado) -> (Exp, Estado)
interpret (c, s) = if isFinal c then (c, s) else interpret (smallStep (c, s))
